<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D SPH Simulation with Three.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #simulation {
            border: 2px solid #3366ff;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 5px;
            text-align: center;
        }
        button {
            padding: 8px 16px;
            background-color: #3366ff;
            border: none;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2255ee;
        }
        button.pause {
            background-color: #ff3366;
        }
        button.pause:hover {
            background-color: #ee2255;
        }
        input[type="range"] {
            width: 150px;
        }
        .info {
            font-size: 0.9em;
            color: #aaaacc;
            text-align: center;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>2D SPH Fluid Simulation</h1>
        <div id="simulation"></div>
        <div class="controls">
            <button id="playPause">Pause</button>
            <div class="control-group">
                <label for="gravitySlider">Gravity: <span id="gravityValue">12000</span></label>
                <input type="range" id="gravitySlider" min="0" max="20000" value="12000">
            </div>
            <div class="control-group">
                <label for="particleSlider">Particles: <span id="particleValue">150</span></label>
                <input type="range" id="particleSlider" min="50" max="500" value="150">
            </div>
            <button id="reset">Reset Simulation</button>
        </div>
        <div class="info">
            <p>This is a 2D SPH (Smoothed Particle Hydrodynamics) simulation using pure Three.js.</p>
            <p>Particle colors represent pressure distribution in the fluid.</p>
        </div>
    </div>

    <script>
        // SPH Parameters
        const REST_DENSITY = 1000; // rest density
        const GAS_CONSTANT = 2000; // gas constant
        const H = 16; // smoothing radius
        const H2 = H * H; // squared smoothing radius
        const MASS = 65; // particle mass
        const VISCOSITY = 250; // viscosity constant
        const DT = 0.0008; // time step
        const BOUND_DAMPING = -0.5; // boundary damping

        // Container dimensions
        const WIDTH = 600;
        const HEIGHT = 400;

        // Kernel constants
        const POLY6 = (315.0 / (64.0 * Math.PI * Math.pow(H, 9)));
        const SPIKY_GRAD = -(45.0 / (Math.PI * Math.pow(H, 6)));
        const VISC_LAP = (45.0 / (Math.PI * Math.pow(H, 6)));

        // Simulation state
        let gravity = 12000;
        let particleCount = 150;
        let isRunning = true;
        let isDragging = false;
        let dragForceX = 0;
        let dragForceY = 0;
        let mouseX = 0;
        let mouseY = 0;

        // Particle class
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.fx = 0;
                this.fy = 0;
                this.density = 0;
                this.pressure = 0;
            }
        }

        // Set up Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111133);
        
        const camera = new THREE.OrthographicCamera(
            -WIDTH / 2, WIDTH / 2, 
            HEIGHT / 2, -HEIGHT / 2, 
            0.1, 1000
        );
        camera.position.z = 100;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(WIDTH, HEIGHT);
        document.getElementById('simulation').appendChild(renderer.domElement);
        
        // Container for particles
        const particles = [];
        const particleMeshes = [];
        
        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Function to initialize particles
        function initParticles() {
            // Clear existing particles
            particles.length = 0;
            particleMeshes.forEach(mesh => scene.remove(mesh));
            particleMeshes.length = 0;
            
            // Create new particles
            const initialRegionWidth = WIDTH * 0.4;
            const initialRegionHeight = HEIGHT * 0.8;
            const startX = -WIDTH/2 + 50;
            const startY = -HEIGHT/2 + 50;
            
            const particlesPerRow = Math.ceil(Math.sqrt(particleCount));
            const spacing = initialRegionWidth / particlesPerRow;
            
            for (let i = 0; i < particleCount; i++) {
                const row = Math.floor(i / particlesPerRow);
                const col = i % particlesPerRow;
                
                const particle = new Particle(
                    startX + col * spacing + (Math.random() * 5), 
                    startY + row * spacing + (Math.random() * 5)
                );
                
                particles.push(particle);
                
                // Create visual representation
                const geometry = new THREE.CircleGeometry(4, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x3399ff,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(particle.x, particle.y, 0);
                
                particleMeshes.push(mesh);
                scene.add(mesh);
            }
        }
        
        // SPH functions
        function computeDensityPressure() {
            for (const particle of particles) {
                particle.density = 0;
                
                // Compute density and pressure
                for (const neighbor of particles) {
                    const dx = neighbor.x - particle.x;
                    const dy = neighbor.y - particle.y;
                    const r2 = dx * dx + dy * dy;
                    
                    if (r2 < H2) {
                        // Compute density with Poly6 kernel
                        particle.density += MASS * POLY6 * Math.pow(H2 - r2, 3);
                    }
                }
                
                // Compute pressure using equation of state
                particle.pressure = GAS_CONSTANT * (particle.density - REST_DENSITY);
            }
        }
        
        function computeForces() {
            for (const particle of particles) {
                let fx = 0;
                let fy = 0;
                
                // Compute pressure and viscosity forces
                for (const neighbor of particles) {
                    if (particle === neighbor) continue;
                    
                    const dx = neighbor.x - particle.x;
                    const dy = neighbor.y - particle.y;
                    const r2 = dx * dx + dy * dy;
                    
                    if (r2 < H2) {
                        const r = Math.sqrt(r2);
                        const factor = (r > 0) ? 1 / r : 0;
                        
                        // Normalized direction
                        const nx = dx * factor;
                        const ny = dy * factor;
                        
                        // Pressure force
                        const pressureForce = -MASS * (particle.pressure + neighbor.pressure) / (2 * neighbor.density) * SPIKY_GRAD * Math.pow(H - r, 2);
                        fx += pressureForce * nx;
                        fy += pressureForce * ny;
                        
                        // Viscosity force
                        const vx = neighbor.vx - particle.vx;
                        const vy = neighbor.vy - particle.vy;
                        const viscForce = VISCOSITY * MASS * VISC_LAP * (H - r) / neighbor.density;
                        fx += viscForce * vx;
                        fy += viscForce * vy;
                    }
                }
                
                // Gravity force
                fy += gravity;
                
                // Mouse interaction
                if (isDragging) {
                    const dx = mouseX - particle.x;
                    const dy = mouseY - particle.y;
                    const r2 = dx * dx + dy * dy;
                    const dragRadius = 50 * 50;
                    
                    if (r2 < dragRadius) {
                        const factor = 1.0 - Math.sqrt(r2) / 50;
                        fx += dragForceX * factor * 500;
                        fy += dragForceY * factor * 500;
                    }
                }
                
                // Store forces
                particle.fx = fx;
                particle.fy = fy;
            }
        }
        
        function integrate() {
            // Update positions, velocities, and handle boundaries
            for (let i = 0; i < particles.length; i++) {
                const particle = particles[i];
                
                // Forward Euler integration
                particle.vx += DT * particle.fx / particle.density;
                particle.vy += DT * particle.fy / particle.density;
                
                particle.x += DT * particle.vx;
                particle.y += DT * particle.vy;
                
                // Boundary conditions
                if (particle.x < -WIDTH/2) {
                    particle.vx *= BOUND_DAMPING;
                    particle.x = -WIDTH/2;
                }
                
                if (particle.x > WIDTH/2) {
                    particle.vx *= BOUND_DAMPING;
                    particle.x = WIDTH/2;
                }
                
                if (particle.y < -HEIGHT/2) {
                    particle.vy *= BOUND_DAMPING;
                    particle.y = -HEIGHT/2;
                }
                
                if (particle.y > HEIGHT/2) {
                    particle.vy *= BOUND_DAMPING;
                    particle.y = HEIGHT/2;
                }
                
                // Update mesh position
                particleMeshes[i].position.set(particle.x, particle.y, 0);
                
                // Update color based on pressure
                const pressureColor = Math.min(1.0, particle.pressure / (GAS_CONSTANT * REST_DENSITY));
                particleMeshes[i].material.color.setRGB(
                    0.2 + pressureColor * 0.8,
                    0.4 + (1.0 - pressureColor) * 0.5,
                    0.8 + (1.0 - pressureColor) * 0.2
                );
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (isRunning) {
                computeDensityPressure();
                computeForces();
                integrate();
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize and start animation
        initParticles();
        animate();
        
        // UI Controls
        const playPauseButton = document.getElementById('playPause');
        const resetButton = document.getElementById('reset');
        const gravitySlider = document.getElementById('gravitySlider');
        const particleSlider = document.getElementById('particleSlider');
        const gravityValue = document.getElementById('gravityValue');
        const particleValue = document.getElementById('particleValue');
        
        playPauseButton.addEventListener('click', () => {
            isRunning = !isRunning;
            playPauseButton.textContent = isRunning ? 'Pause' : 'Resume';
            playPauseButton.classList.toggle('pause', isRunning);
        });
        
        resetButton.addEventListener('click', () => {
            initParticles();
        });
        
        gravitySlider.addEventListener('input', (e) => {
            gravity = parseFloat(e.target.value);
            gravityValue.textContent = gravity;
        });
        
        particleSlider.addEventListener('input', (e) => {
            particleCount = parseInt(e.target.value);
            particleValue.textContent = particleCount;
        });
        
        // Mouse interaction
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            updateMousePosition(e);
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const lastX = mouseX;
                const lastY = mouseY;
                updateMousePosition(e);
                dragForceX = mouseX - lastX;
                dragForceY = mouseY - lastY;
            }
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('mouseleave', () => {
            isDragging = false;
        });
        
        function updateMousePosition(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouseX = ((e.clientX - rect.left) / rect.width) * WIDTH - WIDTH/2;
            mouseY = -((e.clientY - rect.top) / rect.height) * HEIGHT + HEIGHT/2;
        }

        // Add touch support
        renderer.domElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            updateTouchPosition(e.touches[0]);
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging) {
                const lastX = mouseX;
                const lastY = mouseY;
                updateTouchPosition(e.touches[0]);
                dragForceX = mouseX - lastX;
                dragForceY = mouseY - lastY;
            }
        });
        
        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
        });
        
        function updateTouchPosition(touch) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouseX = ((touch.clientX - rect.left) / rect.width) * WIDTH - WIDTH/2;
            mouseY = -((touch.clientY - rect.top) / rect.height) * HEIGHT + HEIGHT/2;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const simulationElement = document.getElementById('simulation');
            const width = Math.min(600, window.innerWidth - 40);
            const height = (width / 600) * 400;
            
            renderer.setSize(width, height);
            
            camera.left = -width / 2;
            camera.right = width / 2;
            camera.top = height / 2;
            camera.bottom = -height / 2;
            camera.updateProjectionMatrix();
        });
        
        // Trigger initial resize
        window.dispatchEvent(new Event('resize'));
    </script>
</body>
</html>
